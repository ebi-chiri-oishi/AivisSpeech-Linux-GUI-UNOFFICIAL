/* tslint:disable */
/* eslint-disable */
/**
 * AivisSpeech Engine
 * AivisSpeech の音声合成エンジンです。
 *
 * The version of the OpenAPI document: latest
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * UserDictWord とほとんど同じだが、ユーザー辞書関連 API の後方互換性を保つための互換レイヤー。
 * 
 * stem, yomi, pronunciation, accent_type, mora_count はリストではなく文字列/数値で表す。
 * 既に UserDictWord にバリデーションが実装されていることから、重複するバリデーション定義は削られている。
 * @export
 * @interface UserDictWordForCompat
 */
export interface UserDictWordForCompat {
    /**
     * 表層形
     * @type {string}
     * @memberof UserDictWordForCompat
     */
    surface: string;
    /**
     * 優先度
     * @type {number}
     * @memberof UserDictWordForCompat
     */
    priority: number;
    /**
     * 文脈 ID
     * @type {number}
     * @memberof UserDictWordForCompat
     */
    contextId?: number;
    /**
     * 品詞
     * @type {string}
     * @memberof UserDictWordForCompat
     */
    partOfSpeech: string;
    /**
     * 品詞細分類1
     * @type {string}
     * @memberof UserDictWordForCompat
     */
    partOfSpeechDetail1: string;
    /**
     * 品詞細分類2
     * @type {string}
     * @memberof UserDictWordForCompat
     */
    partOfSpeechDetail2: string;
    /**
     * 品詞細分類3
     * @type {string}
     * @memberof UserDictWordForCompat
     */
    partOfSpeechDetail3: string;
    /**
     * 活用型
     * @type {string}
     * @memberof UserDictWordForCompat
     */
    inflectionalType: string;
    /**
     * 活用形
     * @type {string}
     * @memberof UserDictWordForCompat
     */
    inflectionalForm: string;
    /**
     * 原形
     * @type {string}
     * @memberof UserDictWordForCompat
     */
    stem: string;
    /**
     * 読み
     * @type {string}
     * @memberof UserDictWordForCompat
     */
    yomi: string;
    /**
     * 発音
     * @type {string}
     * @memberof UserDictWordForCompat
     */
    pronunciation: string;
    /**
     * アクセント型
     * @type {number}
     * @memberof UserDictWordForCompat
     */
    accentType: number;
    /**
     * モーラ数
     * @type {number}
     * @memberof UserDictWordForCompat
     */
    moraCount?: number;
    /**
     * アクセント結合規則
     * @type {string}
     * @memberof UserDictWordForCompat
     */
    accentAssociativeRule: string;
}

/**
 * Check if a given object implements the UserDictWordForCompat interface.
 */
export function instanceOfUserDictWordForCompat(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "surface" in value;
    isInstance = isInstance && "priority" in value;
    isInstance = isInstance && "partOfSpeech" in value;
    isInstance = isInstance && "partOfSpeechDetail1" in value;
    isInstance = isInstance && "partOfSpeechDetail2" in value;
    isInstance = isInstance && "partOfSpeechDetail3" in value;
    isInstance = isInstance && "inflectionalType" in value;
    isInstance = isInstance && "inflectionalForm" in value;
    isInstance = isInstance && "stem" in value;
    isInstance = isInstance && "yomi" in value;
    isInstance = isInstance && "pronunciation" in value;
    isInstance = isInstance && "accentType" in value;
    isInstance = isInstance && "accentAssociativeRule" in value;

    return isInstance;
}

export function UserDictWordForCompatFromJSON(json: any): UserDictWordForCompat {
    return UserDictWordForCompatFromJSONTyped(json, false);
}

export function UserDictWordForCompatFromJSONTyped(json: any, ignoreDiscriminator: boolean): UserDictWordForCompat {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'surface': json['surface'],
        'priority': json['priority'],
        'contextId': !exists(json, 'context_id') ? undefined : json['context_id'],
        'partOfSpeech': json['part_of_speech'],
        'partOfSpeechDetail1': json['part_of_speech_detail_1'],
        'partOfSpeechDetail2': json['part_of_speech_detail_2'],
        'partOfSpeechDetail3': json['part_of_speech_detail_3'],
        'inflectionalType': json['inflectional_type'],
        'inflectionalForm': json['inflectional_form'],
        'stem': json['stem'],
        'yomi': json['yomi'],
        'pronunciation': json['pronunciation'],
        'accentType': json['accent_type'],
        'moraCount': !exists(json, 'mora_count') ? undefined : json['mora_count'],
        'accentAssociativeRule': json['accent_associative_rule'],
    };
}

export function UserDictWordForCompatToJSON(value?: UserDictWordForCompat | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'surface': value.surface,
        'priority': value.priority,
        'context_id': value.contextId,
        'part_of_speech': value.partOfSpeech,
        'part_of_speech_detail_1': value.partOfSpeechDetail1,
        'part_of_speech_detail_2': value.partOfSpeechDetail2,
        'part_of_speech_detail_3': value.partOfSpeechDetail3,
        'inflectional_type': value.inflectionalType,
        'inflectional_form': value.inflectionalForm,
        'stem': value.stem,
        'yomi': value.yomi,
        'pronunciation': value.pronunciation,
        'accent_type': value.accentType,
        'mora_count': value.moraCount,
        'accent_associative_rule': value.accentAssociativeRule,
    };
}

